<!DOCTYPE html>
<html lang="fr">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.56.0-DEV" />

    
    
    

<title>App-Sys: Débuter progressivement • My Cyber Sharing</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="App-Sys: Débuter progressivement"/>
<meta name="twitter:description" content="Commencer pas-à-pas dans le domaine de l&#39;exploitation de failles applicatives systèmes."/>

<meta property="og:title" content="App-Sys: Débuter progressivement" />
<meta property="og:description" content="Commencer pas-à-pas dans le domaine de l&#39;exploitation de failles applicatives systèmes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.mycybersharing.com/cybersecu/app_sys_start_gradually/" />
<meta property="article:published_time" content="2019-02-17T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-02-17T00:00:00+00:00" /><meta property="og:site_name" content="My Cyber Sharing" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">





<link rel="stylesheet" href="/css/hyde-hyde.css">
<link rel="stylesheet" href="/css/custom.css">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://www.mycybersharing.com/">My Cyber Sharing</a>
      </span>
      
        
        
        
        <div class="author-image">
          <img src="https://www.mycybersharing.com//img/avatar.png" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
      
      
      <p class="site__description">
         Hack, Dev, Science... Partageons :) 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">My Cyber Sharing</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/cybersecu/">
						<span>Cybersécu</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/biology/">
						<span>Biologie</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/psychology/">
						<span>Psychologie</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>A Propos</span>
					</a>
				</li>
			 
		
		</li>
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/TheHack42" rel="me" target="blank"><i class="fab fa-twitter fa-lg zoomhover" aria-hidden="true"></i></a>
	
	
	
	<a href="https://github.com/TheHack42" rel="me" target="blank"><i class="fab fa-github fa-lg zoomhover" aria-hidden="true"></i></a>
	
	
	
	
	
	<a href="https://linkedin.com/in/juliengarnier94" rel="me" target="blank"><i class="fab fa-linkedin fa-lg zoomhover" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
	<a href="mailto:juliengarnier94@hotmail.fr" rel="me"><i class="fas fa-at fa-lg zoomhover" aria-hidden="true"></i></a>
	
	
	<a href="https://www.root-me.org/GARNIER" target="blank"><div class="rootme_logo logohover zoomhover"></div></a>
	
</section>

      </div>
    </div>
    
<div class="copyright">
  &copy; 2019 Hack42
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
  
</div>


<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    <article>
  <header>
    <h1>App-Sys: Débuter progressivement</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Feb 17, 2019
    
    
    
    
    
    <br/>
    <i class="fas fa-clock"></i> 12 min read
</div>


  </header>
  
  
  <div class="post">
    

<h2 id="application-système-vous-avez-dit">&ldquo;Application - Système&rdquo;, vous avez dit ?</h2>

<p>Oui, &ldquo;Application - Système&rdquo; :) C&rsquo;est le principe d&rsquo;exploiter une vulnérabilité applicative principalement liée à une erreur de développement et qui peut finir par aboutir à des corruptions de différentes zones mémoire.
<br />
<br />
L&rsquo;objectif ici c&rsquo;est d&rsquo;aborder pas-à-pas ce domaine en passant par les registres, la structure d&rsquo;un exécutable, la pile, le tas&hellip; bref, des choses compliquées pour un débutant qui souhaite se lancer dans l&rsquo;exploitation de failles systèmes.</p>

<h2 id="les-débuts-du-intel-8086">Les débuts du Intel 8086</h2>

<p>L&rsquo;Intel 8086 est un microprocesseur (unité central de traitement) sortie en 1978 dont l&rsquo;objectif est d&rsquo;effectuer des calculs. C&rsquo;est le premier processeur de la famille X86, qui est devenu à ce jour une grande famille et la plus répandue dans le monde des ordinateurs et serveurs informatiques.</p>

<p><img src="/img/Intel_C8086.jpg" alt="C8086" /></p>

<p>Cette petite bébête exécute des instructions machines permettant d&rsquo;effectuer des opérations (l&rsquo;addition, la soustraction, multiplication, ET logique&hellip;), c&rsquo;est ce qui fait fonctionner nos programmes et notre système d&rsquo;exploitation. Cette liste d&rsquo;instructions est appelée &ldquo;jeu d&rsquo;instructions&rdquo;.<br />
Depuis 1978, les processeurs de la famille X86 ont gardé la rétrocompatibilité avec la précédente version. Cela veut dire que le jeu d&rsquo;instructions du 8086 est également présent dans nos dernières générations de processeurs. Il est donc possible de faire fonctionner un programme datant de 1978 sur les derniers processeurs :). Pas mal, non?</p>

<h2 id="et-ces-instructions-ça-ressemble-à-quoi-exactement">Et ces instructions, ça ressemble à quoi exactement ?</h2>

<p>Une instruction c&rsquo;est une suite de bits représentant un ordre pour le microprocesseur. Comme le binaire est difficilement compréhensible pour les humains, le programmeur utilise une abréviation, un simple mot-clé suivis des arguments qui vont désigner l&rsquo;instruction à exécuter. Par la suite, ces mots-clés sont convertis en binaire avant d&rsquo;être envoyé au microprocesseur.</p>

<pre><code>mov ah, 5		; déplace 5 dans &quot;ah&quot; 	: 	ah = 5
add ah, 3		; effectue une addition : 	ah = ah + 3 (&quot;ah&quot; vaut 8 du coup)
</code></pre>

<p>Prenons exemple avec la première instruction :</p>

<pre><code>[mov ah, 5] = [0xb405] = [10110100 00000101] &lt;-- envoyé au microprocesseur
</code></pre>

<p>Les instructions possèdent une taille qui sera variable suivant les arguments passés à celle-ci mais également de l&rsquo;architecture. Si nous reprenons l&rsquo;instruction &ldquo;mov&rdquo; utilisée ci-dessus, elle fait très exactement 2 octets (0xb4 0x05).<br />
<br />
En réalité, le petit mot-clé au début de l&rsquo;instruction est appellé un &ldquo;<strong>opcode</strong>&rdquo; (code opération) et permet de déterminer la nature de l&rsquo;instruction. &ldquo;mov&rdquo; est donc un opcode parmis tant d&rsquo;autres.</p>

<p><img src="/img/instruction.jpg" alt="instruction" /></p>

<h2 id="les-registres-pour-nos-calcules">Les registres pour nos calculs</h2>

<p>Chaque microprocesseur inclut une suite de plusieurs registres, un emplacement mémoire interne au microprocesseur. Il s&rsquo;agit de la mémoire la plus rapide d&rsquo;un ordinateur dû fait qu&rsquo;elle soit présente directement dans l&rsquo;unité de calcul.<br />
Ces petites zones de mémoire ont commencé par faire 16 bits (à l&rsquo;époque du 8086), puis 32 bits et maintenant 64 bits pour les processeurs x64.<br />
Suivant la version que nous souhaitons, le préfixe change : <strong>E</strong> pour obtenir la version 32 bits et <strong>R</strong> pour la version 64 bits du registre.<br />
Voici la liste des registres les plus importants:</p>

<ul>
<li><strong>AX</strong> (16 bits) -&gt; <strong>EAX</strong> (32 bits) -&gt; <strong>RAX</strong> (64 bits)</li>
<li><strong>EBX</strong></li>
<li><strong>ECX</strong></li>
<li><strong>EDX</strong></li>
<li><strong>ESI</strong></li>
<li><strong>EDI</strong></li>
<li><strong>EBP</strong> : <em>adresse de la partie Basse de la Pile</em></li>
<li><strong>ESP</strong> : <em>adresse de la partie Supérieure de la Pile</em></li>
<li><strong>EIP</strong> : <em>adresse de la prochaine instruction à exécuter</em></li>
</ul>

<p><em>La pile est expliquée plus bas, ne vous inquiétez pas ;)</em></p>

<p>Les 4 premiers registres 16 bits sont également décomposés en sous registres.<br />
Par exemple pour AX, nous avons également :</p>

<ul>
<li>AL : registre de poids faible 8 bits</li>
<li>AH : registre de poids fort 8 bits</li>
</ul>

<p><img src="/img/register.jpg" alt="register" /></p>

<p>Ces registres sont utilisés par les différentes instructions du programme.</p>

<h2 id="un-programme-comment-ça-marche-sinon">Un programme comment ça marche sinon ?</h2>

<p>Suivant le système d&rsquo;exploitation, un programme va avoir une structure différente mais similaire. Nous allons nous pencher sur la structure du format de fichier ELF (Executable and Linkable Format) qui est le format des applications sous linux.</p>

<p>Avant qu&rsquo;un programme soit exécuté, il est chargé en mémoire et ensuite la première instruction se trouvant au point d&rsquo;entrée du programme (<strong>EP</strong> pour Entry Point) est exécutée.</p>

<h3 id="le-système-d-adressage-mémoire">Le système d&rsquo;adressage mémoire</h3>

<p>Un programme contient une zone mémoire divisée en octets. Chaque octet de cette zone contient une adresse représentée en <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_hexad%C3%A9cimal">hexadécimal</a> permettant de l&rsquo;utiliser. La première adresse est la plus petite et la dernière la plus grande.</p>

<p><em>Mémoire du programme</em></p>

<table>
<thead>
<tr>
<th>Adresse mémoire</th>
<th>Valeur</th>
</tr>
</thead>

<tbody>
<tr>
<td>4000</td>
<td>B</td>
</tr>

<tr>
<td>4001</td>
<td>o</td>
</tr>

<tr>
<td>4002</td>
<td>n</td>
</tr>

<tr>
<td>&hellip;.</td>
<td>&hellip;</td>
</tr>
</tbody>
</table>

<p>Ces adresses sont codées suivant l&rsquo;architecture de destination. Un programme compilé pour une architecture 32 bits aura des adresses 32 bits et un programme 64 bits, des adresses 64 bits. Il n&rsquo;est pas possible de faire fonctionner un programme 64 bits sur une architecture de processeur 32 bits. En revanche, l&rsquo;inverse est possible en simulant une architecture 32 bits et ainsi un programme 32 bits pourra fonctionner sur un processeur 64 bits.
<br />
<br />
Deux instances d&rsquo;un même programme peuvent utiliser les mêmes adresses sans que cela pose problème&hellip; Ce qui ne devrait pas être possible.<br />
Cela a été rendu possible grâce à l&rsquo;utilisation de la mémoire virtuelle. Sur un système, deux types d&rsquo;adresses existent : les adresses virtuelles et les adresses physiques.<br />
Pour faire simple, un programme a l&rsquo;impression qu&rsquo;il possède toute la mémoire à lui seul parce-qu&rsquo;on lui a attribué une zone mémoire virtuelle et non réelle :</p>

<ul>
<li>Adresse virtuelle : elles sont utilisées à l&rsquo;intérieur d&rsquo;un programme</li>
<li>Adresse physique : c&rsquo;est les adresses utilisées physiquement par les puces présentes sur les barrettes de RAM et également par le noyau (c&rsquo;est lui qui fait la liaison entre les programmes et le matériel)</li>
</ul>

<p><img src="/img/virtual_memory.jpg" alt="virtual memory" /></p>

<p>Voilà pourquoi un programme peut utiliser les mêmes adresses virtuelles mais pas les mêmes adresses physiques. C&rsquo;est le noyau du système d&rsquo;exploitation qui gère les opérations de plus bas niveau en relation avec le matériel et ainsi est amené à manipuler les adresses physiques.</p>

<p>Les adresses sont utilisées partout et pour tout. Tout est adresse, que l&rsquo;on désigne une fonction, une variable, une suite d&rsquo;instructions&hellip; Elles permettent d&rsquo;accéder à une zone de la mémoire en utilisant un identifiant, un nombre entier naturel.</p>

<h3 id="différents-segments">Différents segments</h3>

<p>Un programme contient plusieurs segments (sous-zone mémoire) qui sont des espaces d&rsquo;adressage virtuel contenant toutes les informations permettant de mener à bien l&rsquo;exécution du programme (des chaînes de caractères, des données, les instructions du programme&hellip;).<br />
Les segments sont attachés à des droits d&rsquo;accès (lecture/écriture/exécution) permettant ainsi de les protéger.<br />
<br />
Les principaux segments sont :</p>

<ul>
<li><strong>.text</strong> : contient les instructions du programme (le code)</li>
<li><strong>.data</strong> : contient toutes les variables globales ou statiques possédant une valeur prédéfinie et pouvant être modifiées</li>
<li><strong>.rodata</strong> : à l&rsquo;opposition au segment .data, ce segment est uniquement en lecture seule (<strong>ro</strong> pour read-only)</li>
<li><strong>.bss</strong> : contient toutes les variables globales ou statiques initialisées à zéro ou n&rsquo;ayant pas d&rsquo;initialisation explicite dans le code source</li>
<li><strong>heap</strong> : le tas contient toutes les variables dynamiquement allouées au cours de l&rsquo;exécution du programme</li>
<li><strong>stack</strong> : la pile est une structure <a href="https://fr.wikipedia.org/wiki/Last_in,_first_out">LIFO</a>. Elle est utilisée pour stocker des données durant l&rsquo;exécution du programme pour pouvoir les récupérer plus tard</li>
</ul>

<p>Cette liste n&rsquo;est pas complète mais les principaux segments y sont. Ne vous inquiétez pas si vous n&rsquo;avez pas très bien compris à quoi servaient les segments. Ça viendra avec la pratique.</p>

<p><img src="/img/segments.jpg" alt="segments" /></p>

<p>Ce schéma illustre une représentation de la mémoire virtuelle d&rsquo;un programme. La position des segments ne change pas d&rsquo;une exécution à l&rsquo;autre et reste toujours dans cet ordre.<br />
Nous pouvons constater que la pile grossit du haut vers le bas et que le tas grossit du bas vers le haut. La taille de ces deux segments n&rsquo;est donc pas fixe.</p>

<h3 id="mais-cette-pile-c-est-quoi-en-fait">Mais cette pile, c&rsquo;est quoi en fait ?</h3>

<p>Ça!</p>

<p><img src="/img/stack_1.jpg" alt="stack" /></p>

<p>Bon d&rsquo;accord, pas exactement mais il y a des points communs avec la pile de notre programme. La pile est une structure LIFO (Last in, first out), c&rsquo;est-à-dire que le dernier élément ajouté sera le premier à être retiré. Quand on empile des assiettes les unes sur les autres, il faut d&rsquo;abord retirer la première pour ensuite retirer la deuxième assiette de la pile.</p>

<p><img src="/img/stack_2.jpg" alt="stack" /></p>

<p>La pile est principalement utilisée pour stocker les données nécessaires à l&rsquo;exécution d&rsquo;une fonction et également préserver le pointeur d&rsquo;exécution (registre EIP) afin de reprendre l&rsquo;exécution de cette fonction. On peut y retrouver les arguments de notre fonction mais également les variables locales à celle-ci. Toutes ces choses-là composent la <strong>stack frame</strong> (cadre de pile).</p>

<h3 id="un-exemple-concret">Un exemple concret</h3>

<p>Prenons l&rsquo;exemple d&rsquo;un programme très basic possédant deux fonctions : &ldquo;main&rdquo; et &ldquo;addition&rdquo;.<br />
Le programme va réaliser la somme entre deux nombres et afficher le résultat à l&rsquo;écran :</p>

<pre><code>#include &lt;stdio.h&gt;

void addition(int a, int b) {
    printf(&quot;La somme de %d et %d est %d\n&quot;, a, b, a + b);
}

int main() {
    addition(4, 8); // &lt;= Appel de la fonction &quot;addition&quot;
    return 0;
}
</code></pre>

<p>Lançons la compilation du programme et exécutons-le sans plus attendre :</p>

<pre><code>[julien@hack42]$ gcc main.c -o test -m32
[julien@hack42]$ ./test 
La somme de 4 et 8 est 12
</code></pre>

<p>La commande &ldquo;gcc&rdquo; (GNU Compiler Collection) est un ensemble de compilateurs capables de compiler divers langages de programmation. Ici, nous l&rsquo;utilisons pour compiler un programme en C. L&rsquo;argument &ldquo;-m32&rdquo; permet de compiler notre programme en 32 bits et ainsi notre programme possédera des adresses de 4 octets.</p>

<p><strong><em>Mais du coup qu&rsquo;est-ce qu&rsquo;il se passe concrètement pendant l&rsquo;exécution du programme ?</em></strong><br />
Tout d&rsquo;abord, le programme commence par exécuter la fonction principale &ldquo;main&rdquo; et enfin la fonction &ldquo;addition&rdquo; est appelée.</p>

<blockquote>
<p>En réalité, c&rsquo;est la fonction &ldquo;_start&rdquo; qui appelle notre fonction &ldquo;main&rdquo;. Cette fonction est ajoutée par le compilateur et contient le code de démarrage de l&rsquo;environnement d&rsquo;exécution C. Elle s&rsquo;occupe de configurer des éléments, remplit le tableau d&rsquo;arguments, compte le nombre d&rsquo;arguments, etc&hellip;.</p>
</blockquote>

<p>L&rsquo;opcode &ldquo;call&rdquo; en assembleur est utilisé pour appeler la fonction &ldquo;addition&rdquo;. Regardons à quoi ressemble le code assembleur permettant d&rsquo;effectuer cet appel :</p>

<pre><code>[-------------------------------------code-------------------------------------]
   0x804846f &lt;main+20&gt;:	push   0x8
   0x8048471 &lt;main+22&gt;:	push   0x4
=&gt; 0x8048473 &lt;main+24&gt;:	call   0x8048436 &lt;addition&gt;
   0x8048478 &lt;main+29&gt;:	add    esp,0x10
Guessed arguments:
arg[0]: 0x4 
arg[1]: 0x8
[------------------------------------stack-------------------------------------]
0000| 0xffffc560 --&gt; 0x4 
0004| 0xffffc564 --&gt; 0x8
</code></pre>

<p>On constate que les arguments sont empilés (avec &ldquo;push&rdquo;) sur le haut de la pile et c&rsquo;est seulement après cela que la fonction est appelée.<br />
<strong><em>Petite remarque : les arguments sont empilés en commençant par le dernier afin d&rsquo;avoir le premier en haut de la pile.</em></strong></p>

<p>Maintenant allons voir comment ça se passe pour la fonction &ldquo;addition&rdquo; :</p>

<pre><code>[-------------------------------------code-------------------------------------]
=&gt; 0x8048436 &lt;addition&gt;:	  push   ebp
   0x8048437 &lt;addition+1&gt;:	mov    ebp,esp
   0x8048439 &lt;addition+3&gt;:	sub    esp,0x8
   0x804843c &lt;addition+6&gt;:	mov    edx,DWORD PTR [ebp+0x8]
   0x804843f &lt;addition+9&gt;:	mov    eax,DWORD PTR [ebp+0xc]
[------------------------------------stack-------------------------------------]
0000| 0xffffc55c --&gt; 0x8048478 (&lt;main+29&gt;:	add    esp,0x10)
0004| 0xffffc560 --&gt; 0x4 
0008| 0xffffc564 --&gt; 0x8
</code></pre>

<p>Mais&hellip; il y a un élément supplémentaire en haut de la pile !<br />
Eh oui. Pour pouvoir reprendre l&rsquo;exécution de la fonction &ldquo;main&rdquo;, l&rsquo;instruction &ldquo;call&rdquo; sauvegarde le registre EIP (contenant l&rsquo;instruction suivante) en le plaçant sur la pile. Dans notre exemple, &ldquo;0x8048478&rdquo; (main+29).</p>

<h4 id="initialiser-la-stack-frame-prologue">Initialiser la stack frame (prologue)</h4>

<p><strong>Chaque fonction possède sa propre stack frame</strong> et la fonction &ldquo;addition&rdquo; n&rsquo;y échappe pas. Cela veut dire qu&rsquo;elle doit donc se réserver sa stack frame. Regardez ces deux instructions :</p>

<pre><code>push   ebp
mov    ebp,esp
</code></pre>

<p>Ces deux instructions au début de la fonction &ldquo;addition&rdquo; sont appelées le <strong>prologue</strong>. Elles permettent dans un premier temps de sauvegarder le bas de la pile courante et ensuite d&rsquo;en initialiser une nouvelle. Attendez, laissez-moi vous faire un schéma pour que ça soit plus simple !</p>

<p><img src="/img/stack_frame.jpg" alt="stack frame" /></p>

<p>Vous voyez que la stack frame de &ldquo;addition&rdquo; est vide, parce qu&rsquo;elle n&rsquo;a pas encore été utilisée. De ce fait, le pointeur ESP est identique au pointeur EBP (ils sont confondus). Quand la stack frame de &ldquo;addition&rdquo; va être consommée, alors le pointeur ESP va monter vers les adresses les plus basses.<br />
Maintenant voyons comment récupérer les arguments qui ont été passés à la fonction &ldquo;addition&rdquo;.</p>

<h4 id="récupérer-les-arguments">Récupérer les arguments</h4>

<pre><code>mov    edx,DWORD PTR [ebp+0x8]
mov    eax,DWORD PTR [ebp+0xc]
</code></pre>

<p>En français, cela donnerait :</p>

<ul>
<li>&ldquo;Copier la valeur (DWORD pour <a href="https://fr.wikipedia.org/wiki/Mot_(architecture_informatique)">double mot</a>) pointant en EBP+8 vers le registre EDX&rdquo; (<strong>argument 1</strong>)</li>
<li>&ldquo;Copier la valeur pointant en EBP+12 vers le registre EAX&rdquo; (<strong>argument 2</strong>)</li>
</ul>

<p>Comme EBP pointe sur le haut de la stack frame de &ldquo;main&rdquo; alors il suffit de l&rsquo;utiliser comme référence. Pour récupérer les arguments, nous devons donc faire <strong>&ldquo;EBP+0x8&rdquo; pour le premier</strong> et <strong>&ldquo;EBP+0xc&rdquo; (0xc = 12) pour le second</strong> (regardez le schéma plus haut).</p>

<h4 id="restaurer-la-stack-frame-de-main-épilogue">Restaurer la stack frame de main (épilogue)</h4>

<p>A la fin de la fonction &ldquo;addition&rdquo;, il faut restaurer la stack frame de main et reprendre l&rsquo;exécution de cette dernière. Regardons maintenant les dernières instructions de la fonction &ldquo;addition&rdquo; pour comprendre comment cela fonctionne :</p>

<pre><code>leave  
ret 
</code></pre>

<p>Eh oui, c&rsquo;est ces deux petites instructions qui permettent de restaurer la stack frame de main et ainsi reprendre son exécution normalement. On appelle cette phase, l&rsquo;<strong>épilogue</strong>.</p>

<hr />

<p>Vous vous souvenez que dans le prologue EBP a été empilé en haut de la pile ? L&rsquo;instruction &ldquo;leave&rdquo; va maintenant utiliser cette valeur pour restaurer la stack frame de main :</p>

<p><img src="/img/stack_frame_restore.jpg" alt="stack frame restore" /></p>

<p>Dans l&rsquo;ordre, l&rsquo;instruction leave va effectuer ceci :</p>

<ol>
<li>Restauration de ESP. Pour cela, ESP = EBP+0x4</li>
<li>Restauration de EBP. Pour cela, il utilise la valeur empilée sur la pile tout au début (valeur en bleue sur le schéma). La valeur de EBP vaudra 0xffffc578.</li>
</ol>

<p>L&rsquo;instruction &ldquo;leave&rdquo; est équivalente à ceci :</p>

<pre><code>lea    esp,[ebp+0x4]				; esp = ebp + 4
mov    ebp,DWORD PTR [ebp]	; ebp = valeur de ebp
</code></pre>

<hr />

<p>Par la suite, l&rsquo;instruction &ldquo;ret&rdquo; (pour return) va permettre de reprendre l&rsquo;exécution de la fonction &ldquo;main&rdquo; et ceci est possible parce que EIP a été empilé sur la pile (en rouge sur le schéma) par l&rsquo;instruction &ldquo;call&rdquo;.</p>

<p>L&rsquo;instruction &ldquo;ret&rdquo; est équivalente à ceci :</p>

<pre><code>jmp    DWORD PTR [esp]	; saute à la valeur (adresse) présente sur le haut de la pile
add    esp,0x4 					; ajoute 4 à esp
</code></pre>

<hr />

<p>Et voilà, la stack frame de main a été restaurée correctement et nous avons repris l&rsquo;exécution de main là où on s&rsquo;était arrêté au moment du &ldquo;call&rdquo; (main+29) :</p>

<pre><code>[----------------------------------registers-----------------------------------]
EBP: 0xffffc578 --&gt; 0x0 
ESP: 0xffffc560 --&gt; 0x4 
EIP: 0x8048478 (&lt;main+29&gt;:	add    esp,0x10)
[-------------------------------------code-------------------------------------]
   0x804846f &lt;main+20&gt;:	push   0x8
   0x8048471 &lt;main+22&gt;:	push   0x4
   0x8048473 &lt;main+24&gt;:	call   0x8048436 &lt;addition&gt;
=&gt; 0x8048478 &lt;main+29&gt;:	add    esp,0x10
[------------------------------------stack-------------------------------------]
0000| 0xffffc560 --&gt; 0x4 
0004| 0xffffc564 --&gt; 0x8
</code></pre>

<p><img src="/img/stack_call.gif" alt="stack call" /></p>

<h3 id="le-mot-de-la-fin">Le mot de la fin</h3>

<p>J&rsquo;espère que ce tuto d&rsquo;initiation sur les failles systèmes vous aura plu et que vous l&rsquo;avez compris dans sa globalité. Si vous l&rsquo;avez apprécié, n&rsquo;hésitez pas à mettre un petit &ldquo;j&rsquo;aime&rdquo; en bas de la page. Si vous avez des questions sur une partie que vous n&rsquo;avez pas comprise ou tout simplement envie de partager votre avis, n&rsquo;hésitez pas à commenter la page. Et même (surtout) si j&rsquo;ai fait une boulette.</p>

<p>Maintenant vous êtes prêt à passer à la suite, l&rsquo;exploitation d&rsquo;un buffer overflow :)</p>

  </div>
  

<div class="navigation navigation-single">
    
    
    <a href="/cybersecu/app_sys_buffer_overflow/" class="navigation-next">
      <span class="navigation-tittle">App-Sys: Sur les traces d&#39;un buffer overflow</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  
    
        <div id="disqus_thread"></div>
<script type="text/javascript">
    

    (function () {
    if (location.hostname === "localhost" ||
      location.hostname === "127.0.0.1" ||
      location.hostname === "") {
      return;
    }
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    var disqus_shortname = 'mycybersharing';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || 
      document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

<noscript>
  Please enable JavaScript to view the
  <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by
  <span class="logo-disqus">Disqus</span>
</a>

    


</article>


        </div>
        
    
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-134696947-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
    
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    




    



    </body>
</html>
